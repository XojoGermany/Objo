<?xml version="1.0" encoding="UTF-8"?>
<RBProject version="2021r2" FormatVersion="2" MinIDEVersion="20070100">
<block type="Module" ID="1329240063">
 <ObjName>ObjoTokeniser</ObjName>
 <ObjContainerID>968105983</ObjContainerID>
 <IsClass>1</IsClass>
 <ItemFlags>1</ItemFlags>
 <IsInterface>0</IsInterface>
 <Compatibility></Compatibility>
 <Method>
  <ItemName>Tokenise</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Takes Objo source code, tokenises it and returns an array of ObjoTokens.</CodeDescription>
  <PartID>48689151</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Tokenise(s As String) As ObjoToken()</SourceLine>
   <SourceLine>/// Takes Objo source code, tokenises it and returns an array of ObjoTokens.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Reset</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Standardise line endings to Unix.</SourceLine>
   <SourceLine>s = s.ReplaceLineEndings(EndOfLine.UNIX)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Keep a reference to the source.</SourceLine>
   <SourceLine>Source = s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Split the source into characters.</SourceLine>
   <SourceLine>Chars = s.Split("")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Split into lines for easy error handling.</SourceLine>
   <SourceLine>Lines = s.Split(EndOfLine.UNIX)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Keep getting tokens until we've consumed all of the source code.</SourceLine>
   <SourceLine>Do</SourceLine>
   <SourceLine>NextToken</SourceLine>
   <SourceLine>Loop Until ReachedEOF</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Tokens</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>ObjoToken()</ItemResult>
 </Method>
 <Method>
  <ItemName>Reset</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Resets the tokeniser.</CodeDescription>
  <PartID>720474111</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Reset()</SourceLine>
   <SourceLine>/// Resets the tokeniser.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Source = ""</SourceLine>
   <SourceLine>Chars.ResizeTo(-1)</SourceLine>
   <SourceLine>Lines.ResizeTo(-1)</SourceLine>
   <SourceLine>Tokens.ResizeTo(-1)</SourceLine>
   <SourceLine>TokenStart = 0</SourceLine>
   <SourceLine>Current = 0</SourceLine>
   <SourceLine>LineNumber = 1</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ReachedEOF</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns True if we've reached the end of the source code.</CodeDescription>
  <PartID>747356159</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ReachedEOF() As Boolean</SourceLine>
   <SourceLine>/// Returns True if we've reached the end of the source code.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If Tokens.Count &gt; 0 And Tokens(Tokens.LastIndex).Type = TokenTypes.EOF Then</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>NextToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Scans the source code from the current character and adds the next token to the [Tokens] array</CodeDescription>
  <PartID>534507519</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub NextToken()</SourceLine>
   <SourceLine>/// Scans the source code from the current character and adds the next </SourceLine>
   <SourceLine>/// token to the [Tokens] array.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Store the current position so we know where in `Chars` this </SourceLine>
   <SourceLine>// token begins.</SourceLine>
   <SourceLine>TokenStart = Current</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Skip over meaningless whitespace.</SourceLine>
   <SourceLine>SkipWhitespace</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Have we reached the end of the source code?</SourceLine>
   <SourceLine>If AtEnd Then</SourceLine>
   <SourceLine>AddToken(MakeToken(TokenTypes.EOL))</SourceLine>
   <SourceLine>AddToken(MakeToken(TokenTypes.EOF))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the character to evaluate.</SourceLine>
   <SourceLine>Var c As String = Advance</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ====================================================================</SourceLine>
   <SourceLine>// Ampersand-prefixed literals.</SourceLine>
   <SourceLine>// ====================================================================</SourceLine>
   <SourceLine>If c = "&amp;" Then</SourceLine>
   <SourceLine>Select Case Peek</SourceLine>
   <SourceLine>Case "b"</SourceLine>
   <SourceLine>// Binary literal (e.g. &amp;b0011).</SourceLine>
   <SourceLine>If AddBinaryLiteralToken Then Return</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "o"</SourceLine>
   <SourceLine>// Octal literal (e.g. &amp;o123).</SourceLine>
   <SourceLine>If AddOctalLiteralToken Then Return</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "h"</SourceLine>
   <SourceLine>// Hexadecimal literal (e.g. &amp;hFF).</SourceLine>
   <SourceLine>If AddHexLiteralToken Then Return</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "c"</SourceLine>
   <SourceLine>// Color literal (e.g. &amp;cFFAADD00).</SourceLine>
   <SourceLine>If AddColorLiteralToken Then Return</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "u"</SourceLine>
   <SourceLine>// Unicode literal (e.g. &amp;u0009).</SourceLine>
   <SourceLine>If AddUnicodeLiteralToken Then Return</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Numbers.</SourceLine>
   <SourceLine>If IsNumeric(c) Then</SourceLine>
   <SourceLine>AddNumberToken</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ========================</SourceLine>
   <SourceLine>// Single character tokens.</SourceLine>
   <SourceLine>// ========================</SourceLine>
   <SourceLine>Select Case c</SourceLine>
   <SourceLine>Case "="</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Equals))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case ","</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Comma))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "."</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Dot))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case ":"</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Colon))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "("</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.LParen))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case ")"</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.RParen))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "["</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.LSquare))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "]"</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.RSquare))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "{"</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.LCurly))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "}"</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.RCurly))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "_"</SourceLine>
   <SourceLine>// Contiguous underscores are an error.</SourceLine>
   <SourceLine>If Tokens.Count &gt; 0 And _</SourceLine>
   <SourceLine>Tokens(Tokens.LastIndex).Type = Objo.TokenTypes.Underscore Then</SourceLine>
   <SourceLine>Error("Unexpected underscore (`_`).")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Underscore))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Case "|"</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Pipe))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "^"</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Caret))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Case "&amp;"</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Ampersand))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ====================================================================</SourceLine>
   <SourceLine>// Single OR multiple character tokens.</SourceLine>
   <SourceLine>// `c` is a character that can occur on its own or can occur in </SourceLine>
   <SourceLine>// combination with one or more characters.</SourceLine>
   <SourceLine>// ====================================================================</SourceLine>
   <SourceLine>Select Case c</SourceLine>
   <SourceLine>Case "-"</SourceLine>
   <SourceLine>If Match("=") Then // -=</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.MinusEqual))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Else // -</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Minus))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Case "+"</SourceLine>
   <SourceLine>If Match("=") Then // +=</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.PlusEqual))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Else // +</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Plus))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Case "/"</SourceLine>
   <SourceLine>If Match("=") Then ' /=</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.ForwardSlashEqual))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Else ' /</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.ForwardSlash))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Case "*"</SourceLine>
   <SourceLine>If Match("=") Then // *=</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.StarEqual))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Else // *</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Star))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Case "&lt;"</SourceLine>
   <SourceLine>If Match("&gt;") Then // &lt;&gt;</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.NotEqual))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>ElseIf Match("=") Then // &lt;=</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.LessEqual))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>ElseIf Match("&lt;") Then // &lt;&lt;</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.LessLess))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Less))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Case "&gt;"</SourceLine>
   <SourceLine>If Match("=") Then // &gt;=</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.GreaterEqual))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>ElseIf Match("&gt;") Then // &gt;&gt;</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.GreaterGreater))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Greater))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Case "?"</SourceLine>
   <SourceLine>If Match("?") Then</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.QueryQuery))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Tokens.Add(MakeToken(Objo.TokenTypes.Query))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ====================================================================</SourceLine>
   <SourceLine>// Strings.</SourceLine>
   <SourceLine>// ====================================================================</SourceLine>
   <SourceLine>If c = """" Then</SourceLine>
   <SourceLine>// Raw string literal.</SourceLine>
   <SourceLine>AddRawStringLiteralToken</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>ElseIf c = "'" Then</SourceLine>
   <SourceLine>// Escaped string literal.</SourceLine>
   <SourceLine>AddEscapedStringLiteralToken</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// =================================================================</SourceLine>
   <SourceLine>// Identifiers, and reserved words (e.g. keywords, booleans, etc).</SourceLine>
   <SourceLine>// =================================================================</SourceLine>
   <SourceLine>If StringKit.IsLetter(c) Then</SourceLine>
   <SourceLine>AddToken(IdentifierOrReservedWord)</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ====================================================================</SourceLine>
   <SourceLine>// Danger zone.</SourceLine>
   <SourceLine>// ====================================================================</SourceLine>
   <SourceLine>Error("Unexpected character `" + c + "`.")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>SkipWhitespace</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Advances past meaningless whitespace.</CodeDescription>
  <PartID>1587967999</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub SkipWhitespace()</SourceLine>
   <SourceLine>/// Advances past meaningless whitespace.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Updates [TokenStart] if needed.</SourceLine>
   <SourceLine>/// Handles newlines following an underscore token.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Do</SourceLine>
   <SourceLine>Select Case Peek</SourceLine>
   <SourceLine>Case "" // End of the source code.</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case " ", &amp;u0009 // Space or horizontal tab.</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "/"</SourceLine>
   <SourceLine>// Could this be the start of a "//" comment?</SourceLine>
   <SourceLine>If PeekNext = "/" Then</SourceLine>
   <SourceLine>ConsumeComment</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case EndOfLine.UNIX</SourceLine>
   <SourceLine>// Is the last token an underscore? If so, we remove the underscore</SourceLine>
   <SourceLine>// token and omit adding an EOL token. To the parser, this will</SourceLine>
   <SourceLine>// appear as though the tokens before the underscore token and those</SourceLine>
   <SourceLine>// following this newline are on the same line.</SourceLine>
   <SourceLine>If Tokens.Count &gt; 0 And _ </SourceLine>
   <SourceLine>Tokens(Tokens.LastIndex).Type = Objo.TokenTypes.Underscore Then</SourceLine>
   <SourceLine>Call Tokens.Pop</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>LineNumber = LineNumber + 1</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>AddToken(MakeToken(TokenTypes.EOL))</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>LineNumber = LineNumber + 1</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Update the start position of the next token.</SourceLine>
   <SourceLine>TokenStart = Current</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Peek</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns the current character but doesn't consume it. If we've the end it returns "".</CodeDescription>
  <PartID>866492415</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Peek() As String</SourceLine>
   <SourceLine>/// Returns the current character but doesn't consume it.</SourceLine>
   <SourceLine>/// If we've reached the end it returns "".</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return If(Current &lt;= Chars.LastIndex, Chars(Current), "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Advance</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Consumes and returns the current character in the source code.</CodeDescription>
  <PartID>1354160127</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Advance() As String</SourceLine>
   <SourceLine>/// Consumes and returns the current character in the source code.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Current = Current + 1</SourceLine>
   <SourceLine>Return Chars(Current - 1)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ConsumeComment</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Consumes all characters until EOL or EOF.</CodeDescription>
  <PartID>1059149823</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub ConsumeComment()</SourceLine>
   <SourceLine>/// Consumes all characters until EOL or EOF.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes we are at the beginning of a comment.</SourceLine>
   <SourceLine>/// In Objo, comments begin with `//`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Comments go to the end of the line so keep advancing</SourceLine>
   <SourceLine>// until we reach a newline or the source code end.</SourceLine>
   <SourceLine>Do</SourceLine>
   <SourceLine>If Peek = EndOfLine.UNIX Then</SourceLine>
   <SourceLine>AddToken(MakeToken(TokenTypes.EOL))</SourceLine>
   <SourceLine>LineNumber = LineNumber + 1</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf AtEnd Then</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>AddToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Adds the passed token to the internal [Tokens] array.</CodeDescription>
  <PartID>1463877631</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub AddToken(token As ObjoToken)</SourceLine>
   <SourceLine>/// Adds the passed token to the internal [Tokens] array.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Handle EOLs.</SourceLine>
   <SourceLine>If token.Type = TokenTypes.EOL Then</SourceLine>
   <SourceLine>If Tokens.Count = 0 Then</SourceLine>
   <SourceLine>// Prevent the first token from being an EOL.</SourceLine>
   <SourceLine>Return </SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>// Disallow contiguous EOLs.</SourceLine>
   <SourceLine>If Tokens(Tokens.LastIndex).Type = TokenTypes.EOL Then</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Add this token.</SourceLine>
   <SourceLine>Tokens.Add(token)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>token As ObjoToken</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>AtEnd</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns True if we're at the end of the source code.</CodeDescription>
  <PartID>1326469119</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function AtEnd() As Boolean</SourceLine>
   <SourceLine>/// Returns True if we're at the end of the source code.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Current &gt;= Chars.Count</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>PeekNext</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns the next character but does not consume it. Returns "" if at the end.</CodeDescription>
  <PartID>1599588351</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function PeekNext() As String</SourceLine>
   <SourceLine>/// Returns the next character but does not consume it.</SourceLine>
   <SourceLine>/// Returns "" if at the end.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If Current + 1 &lt;= Chars.LastIndex Then</SourceLine>
   <SourceLine>Return Chars(Current + 1)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return ""</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>AddBinaryLiteralToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1634871295</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function AddBinaryLiteralToken() As Boolean</SourceLine>
   <SourceLine>/// Attempts to add a binary literal token and returns True if successful.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// We assume that [Current] points to the "&amp;" and that the next character </SourceLine>
   <SourceLine>/// is **definitely** a "b".</SourceLine>
   <SourceLine>/// Example:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// &amp;b0011</SourceLine>
   <SourceLine>///  ^</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Move past the "b" character.</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We need to see at least one binary character.</SourceLine>
   <SourceLine>If Not IsBinaryDigit(Peek) Then</SourceLine>
   <SourceLine>// Rewind a character (since we advanced past the "b").</SourceLine>
   <SourceLine>Current = Current - 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Consume all contiguous binary digits.</SourceLine>
   <SourceLine>While IsBinaryDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The next character must be non alphanumeric.</SourceLine>
   <SourceLine>If IsAlpha(Peek) And Not AtEnd Then</SourceLine>
   <SourceLine>// Rewind to the character after the token start position.</SourceLine>
   <SourceLine>Current = TokenStart + 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the lexeme. +2 accounts for the "&amp;b" prefix.</SourceLine>
   <SourceLine>Var lexeme As String = _</SourceLine>
   <SourceLine>Source.Middle(TokenStart + 2, Current - TokenStart - 1)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Create and add this token.</SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.BinaryLiteral, TokenStart, _</SourceLine>
   <SourceLine>LineNumber, lexeme))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>IsBinaryDigit</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns True if [c] is `0` or `1`.</CodeDescription>
  <PartID>1239797759</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsBinaryDigit(c As String) As Boolean</SourceLine>
   <SourceLine>/// Returns True if [c] is `0` or `1`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return c = "0" Or c = "1"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>c As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>IsAlpha</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns True if [c] is considered alphanumeric.</CodeDescription>
  <PartID>388605951</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsAlpha(c As String) As Boolean</SourceLine>
   <SourceLine>/// Returns True if [c] is considered alphanumeric.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// This is **not** exhaustive because the [Objo.NonAlpha] dictionary</SourceLine>
   <SourceLine>/// doesn't contain every non-alpha character.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Not Objo.NonAlpha.HasKey(c)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>c As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>AddColorLiteralToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Attempts to add a color literal token beginning at the current position. Returns True if successful.</CodeDescription>
  <PartID>1446277119</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function AddColorLiteralToken() As Boolean</SourceLine>
   <SourceLine>/// Attempts to add a color literal token beginning at the current position. </SourceLine>
   <SourceLine>/// Returns True if successful.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that [Current] points to the "&amp;" character illustrated below </SourceLine>
   <SourceLine>/// **and** that the next character is definitely a "c".</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// &amp;cFFEEDD</SourceLine>
   <SourceLine>/// ^</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Move past the "c" character.</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We need to see at least one hex character.</SourceLine>
   <SourceLine>If Not IsHexDigit(Peek) Then</SourceLine>
   <SourceLine>// Rewind a character (since we advanced past the "c").</SourceLine>
   <SourceLine>Current = Current - 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Consume all contiguous hex digits.</SourceLine>
   <SourceLine>While IsHexDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the lexeme. The +2 accounts for the "&amp;c" prefix.</SourceLine>
   <SourceLine>Var iMax As Integer = Current - 1</SourceLine>
   <SourceLine>Var tmp() As String</SourceLine>
   <SourceLine>For i As Integer = TokenStart + 2 To iMax</SourceLine>
   <SourceLine>tmp.Add(Chars(i))</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine>Var lexeme As String = String.FromArray(tmp, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Make sure there are at most 8 hex characters in the lexeme (RRGGBBAA).</SourceLine>
   <SourceLine>If lexeme.Length &gt; 8 Then</SourceLine>
   <SourceLine>// Rewind to the character after the token start position.</SourceLine>
   <SourceLine>Current = TokenStart + 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The current character mustn't be alphanumeric or the end of the line or </SourceLine>
   <SourceLine>// else this can't be a color literal.</SourceLine>
   <SourceLine>If IsAlpha(Peek) And Not AtEnd Then</SourceLine>
   <SourceLine>// Rewind to the character after the token start position.</SourceLine>
   <SourceLine>Current = TokenStart + 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Create and add this token.</SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.ColorLiteral, TokenStart, _</SourceLine>
   <SourceLine>LineNumber, lexeme))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>IsHexDigit</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>True if [c] is a valid hexadecimal digit (0-9, a-f, A-F).</CodeDescription>
  <PartID>1774196735</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsHexDigit(c As String) As Boolean</SourceLine>
   <SourceLine>/// True if [c] is a valid hexadecimal digit (0-9, a-f, A-F).</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that [c] is a single character in length.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case c.Asc</SourceLine>
   <SourceLine>Case 48 To 57 // 0-9</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine>Case 65 To 70 // A-F</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine>Case 97 To 102 // a-f</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>c As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>AddOctalLiteralToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Attempts to add an octal literal token beginning at the current position. Returns True if successful.</CodeDescription>
  <PartID>862625791</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function AddOctalLiteralToken() As Boolean</SourceLine>
   <SourceLine>/// Attempts to add an octal literal token beginning at the current position.</SourceLine>
   <SourceLine>/// Returns True if successful.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that [Current] points to the "&amp;" character illustrated below **and** </SourceLine>
   <SourceLine>/// that the next character is definitely an "o":</SourceLine>
   <SourceLine>/// ``` </SourceLine>
   <SourceLine>/// &amp;hFFA1</SourceLine>
   <SourceLine>/// ^</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Move past the "o" character.</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We need to see at least one octal character.</SourceLine>
   <SourceLine>If Not IsOctalDigit(Peek) Then</SourceLine>
   <SourceLine>// Rewind a character (since we advanced past the "o").</SourceLine>
   <SourceLine>Current = Current - 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Consume all contiguous octal digits.</SourceLine>
   <SourceLine>While IsOctalDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The next character can't alphanumeric or the end of a line.</SourceLine>
   <SourceLine>If IsAlpha(Peek) And Not AtEnd Then</SourceLine>
   <SourceLine>// Rewind to the character after the token start position.</SourceLine>
   <SourceLine>Current = TokenStart + 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the lexeme. +2 accounts for the "&amp;o" prefix.</SourceLine>
   <SourceLine>Var lexeme As String = _</SourceLine>
   <SourceLine>Source.Middle(TokenStart + 2, Current - TokenStart - 1)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Create and add this token.</SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.OctalLiteral, TokenStart, _</SourceLine>
   <SourceLine>LineNumber, lexeme))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>IsOctalDigit</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>True if [c] is a valid octal digit (0-7).</CodeDescription>
  <PartID>117049343</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsOctalDigit(c As String) As Boolean</SourceLine>
   <SourceLine>/// True if [c] is a valid octal digit (0-7).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case c.Asc</SourceLine>
   <SourceLine>Case 48 To 55 // 0-7</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>c As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>AddHexLiteralToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Attempts to add a hexadecimal literal token beginning at the current position. Returns True if successful.</CodeDescription>
  <PartID>862306303</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function AddHexLiteralToken() As Boolean</SourceLine>
   <SourceLine>/// Attempts to add a hex literal token beginning at the current position.</SourceLine>
   <SourceLine>/// Returns True if successful.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that [Current] points to the "&amp;" character illustrated below **and** </SourceLine>
   <SourceLine>/// that the next character is definitely a "h":</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// &amp;hFFA1</SourceLine>
   <SourceLine>///  ^</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Move past the "h" character.</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We need to see at least one hex character.</SourceLine>
   <SourceLine>If Not IsHexDigit(Peek) Then</SourceLine>
   <SourceLine>// Rewind a character (since we advanced past the "h").</SourceLine>
   <SourceLine>Current = Current - 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Consume all contiguous hex digits.</SourceLine>
   <SourceLine>While IsHexDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The next character can't alphanumeric or the end of a line.</SourceLine>
   <SourceLine>If IsAlpha(Peek) And Not AtEnd Then</SourceLine>
   <SourceLine>// Rewind to the character after the token start position.</SourceLine>
   <SourceLine>Current = TokenStart + 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the lexeme. +2 accounts for the "&amp;h" prefix.</SourceLine>
   <SourceLine>Var lexeme As String = _</SourceLine>
   <SourceLine>Source.Middle(TokenStart + 2, Current - TokenStart - 1)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Create and add this token.</SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.HexLiteral, TokenStart, _</SourceLine>
   <SourceLine>LineNumber, lexeme))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>AddUnicodeLiteralToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Attempts to add a unicode literal token beginning at the current position. Returns True if successful.</CodeDescription>
  <PartID>1187420159</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function AddUnicodeLiteralToken() As Boolean</SourceLine>
   <SourceLine>/// Attempts to add a unicode literal token beginning at the current position. </SourceLine>
   <SourceLine>/// Returns True if successful.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that [Current] points to the "&amp;" character illustrated below **and** </SourceLine>
   <SourceLine>/// that the next character is definitely a "u":</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// &amp;u0009</SourceLine>
   <SourceLine>/// ^</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Move past the "u" character.</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We need to see at least one hex character.</SourceLine>
   <SourceLine>If Not IsHexDigit(Peek) Then</SourceLine>
   <SourceLine>// Rewind a character (since we advanced past the "u").</SourceLine>
   <SourceLine>Current = Current - 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Consume all contiguous hex digits.</SourceLine>
   <SourceLine>While IsHexDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The next character can't be alphanumeric.</SourceLine>
   <SourceLine>If IsAlpha(Peek) And Not AtEnd Then</SourceLine>
   <SourceLine>// Rewind to the character after the token start position.</SourceLine>
   <SourceLine>Current = TokenStart + 1</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the lexeme. +2 accounts for the "&amp;u" prefix.</SourceLine>
   <SourceLine>Var lexeme As String = _</SourceLine>
   <SourceLine>Source.Middle(TokenStart + 2, Current - TokenStart - 1)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Create and add this token.</SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.UnicodeLiteral, TokenStart, _</SourceLine>
   <SourceLine>LineNumber, lexeme))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>AddNumberToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Consumes and adds a number token starting at [Current].</CodeDescription>
  <PartID>611403775</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub AddNumberToken()</SourceLine>
   <SourceLine>/// Consumes and adds a number token starting at [Current].</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that [Current] points at a digit.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>While IsDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Is this a double?</SourceLine>
   <SourceLine>If Peek = "." And IsDigit(PeekNext) Then</SourceLine>
   <SourceLine>Call Advance // Consume the dot.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>While IsDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Is there an exponent?</SourceLine>
   <SourceLine>If Peek = "e" Then</SourceLine>
   <SourceLine>Var nextChar As String = PeekNext</SourceLine>
   <SourceLine>If nextChar = "-" Or nextChar = "+" Then</SourceLine>
   <SourceLine>// Advance twice to consume the e/E and sign character.</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>While IsDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf IsDigit(nextChar) Then</SourceLine>
   <SourceLine>Call Advance // Consume the e/E character.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>While IsDigit(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Add this token.</SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.Number, TokenStart, LineNumber, _</SourceLine>
   <SourceLine>Source.Middle(TokenStart, Current - TokenStart)))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>IsDigit</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns True if [character] is a digit in the range 0-9.</CodeDescription>
  <PartID>1870362623</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsDigit(character As String) As Boolean</SourceLine>
   <SourceLine>/// Returns True if [character] is a digit in the range 0-9.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case character.Asc</SourceLine>
   <SourceLine>Case 48 To 57</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>character As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>MakeToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns a new token of the specified type. Used for tokens without lexemes.</CodeDescription>
  <PartID>593788927</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function MakeToken(type As TokenTypes) As ObjoToken</SourceLine>
   <SourceLine>/// Returns a new token of the specified type. </SourceLine>
   <SourceLine>/// Used for tokens without lexemes.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return New ObjoToken(type, TokenStart, LineNumber)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>type As TokenTypes</ItemParams>
  <ItemResult>ObjoToken</ItemResult>
 </Method>
 <Method>
  <ItemName>Match</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>If the next character matches [c] then it's consumed and True is returned. Otherwise the character is left alone and False is returned.</CodeDescription>
  <PartID>1022644223</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Match(c As String) As Boolean</SourceLine>
   <SourceLine>/// If the next character matches [c] then it's consumed and True is </SourceLine>
   <SourceLine>/// returned. Otherwise the character is left alone and False is returned.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If Peek = c Then</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>c As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>Error</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Raises an [ObjoTokeniserException] at the current position.</CodeDescription>
  <PartID>800813055</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Error(message As String)</SourceLine>
   <SourceLine>/// Raises an [ObjoTokeniserException] at the current position.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#Pragma BreakOnExceptions False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var e As New ObjoTokeniserException(message)</SourceLine>
   <SourceLine>e.LineNumber = LineNumber</SourceLine>
   <SourceLine>// -1 as the tokeniser has already moved past the offending character.</SourceLine>
   <SourceLine>e.AbsoluteStartPosition = Current - 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We know the 0-based index of the current character in the source code </SourceLine>
   <SourceLine>// but we need to translate that to the 0-based index within the </SourceLine>
   <SourceLine>// current line. We'll loop over the array of all characters in the </SourceLine>
   <SourceLine>// source code, counting the newlines until we get to the first </SourceLine>
   <SourceLine>// character of the line we're currently on. We can then compute the </SourceLine>
   <SourceLine>// index of the offending character by subtracting the position of the </SourceLine>
   <SourceLine>// start of this line from the current character position. This is a </SourceLine>
   <SourceLine>// bit convoluted but it'll only happen when there's an unrecoverable </SourceLine>
   <SourceLine>// tokeniser error so we don't need to care about performance that much.</SourceLine>
   <SourceLine>Var newLineCount As Integer = 1</SourceLine>
   <SourceLine>Var lineStartCharIndex As Integer = 0</SourceLine>
   <SourceLine>For i As Integer = 0 To Chars.LastIndex</SourceLine>
   <SourceLine>If newLineCount = LineNumber Then</SourceLine>
   <SourceLine>lineStartCharIndex = i</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>ElseIf Chars(i) = EndOfLine.UNIX Then</SourceLine>
   <SourceLine>newLineCount = newLineCount + 1</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// `lineStartCharIndex` now holds the 0-based position in the source </SourceLine>
   <SourceLine>// code of the first character of the line that the error has occurred on.</SourceLine>
   <SourceLine>// Compute the relative position of the character causing the </SourceLine>
   <SourceLine>// error on the line.</SourceLine>
   <SourceLine>e.LineCharacterPosition = e.AbsoluteStartPosition - lineStartCharIndex</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Raise e</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>message As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>AddRawStringLiteralToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Attempts to add a raw string literal token.</CodeDescription>
  <PartID>420435967</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub AddRawStringLiteralToken()</SourceLine>
   <SourceLine>/// Attempts to add a raw string literal token.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Raw string literals begin and end with a double quote ("). </SourceLine>
   <SourceLine>/// They may contain &gt;= 0 escaped double quotes ("").</SourceLine>
   <SourceLine>/// This method assumes that the current character being evaluated is </SourceLine>
   <SourceLine>/// immediately after the opening double quote:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// "Hello"</SourceLine>
   <SourceLine>///  ^</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Cache the starting line number (in case this is a multiline string).</SourceLine>
   <SourceLine>Var originalLineNumber As Integer = LineNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Keep consuming characters until we hit a `"`.</SourceLine>
   <SourceLine>Var terminated As Boolean = False</SourceLine>
   <SourceLine>Var containsEscapedQuotes As Boolean = False</SourceLine>
   <SourceLine>Var c As String</SourceLine>
   <SourceLine>While Not AtEnd</SourceLine>
   <SourceLine>c = Advance</SourceLine>
   <SourceLine>If c = QUOTE Then</SourceLine>
   <SourceLine>// If the next character is a `"` then this is an escaped quote.</SourceLine>
   <SourceLine>If Match(QUOTE) Then</SourceLine>
   <SourceLine>containsEscapedQuotes = True</SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>terminated = True</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>ElseIf c = EndOfLine.UNIX Then</SourceLine>
   <SourceLine>// A multiline string literal.</SourceLine>
   <SourceLine>LineNumber = LineNumber + 1</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Make sure the literal was terminated.</SourceLine>
   <SourceLine>If Not terminated Then</SourceLine>
   <SourceLine>Error("Unterminated string literal. Expected a closing double quote.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Quick check for an empty string.</SourceLine>
   <SourceLine>If Current = TokenStart + 1 Then</SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.StringLiteral, TokenStart, _</SourceLine>
   <SourceLine>originalLineNumber))</SourceLine>
   <SourceLine>Return</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the lexeme (everything between the opening and closing `"`).</SourceLine>
   <SourceLine>// +1 accounts for the opening `"` and -2 accounts for the closing `"`.</SourceLine>
   <SourceLine>Var lexeme As String = Source.Middle(TokenStart + 1, Current - TokenStart - 2)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// If there are any `""`, convert them to `"`.</SourceLine>
   <SourceLine>If containsEscapedQuotes Then</SourceLine>
   <SourceLine>lexeme = lexeme.ReplaceAll(QUOTE + QUOTE, QUOTE)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.StringLiteral, _</SourceLine>
   <SourceLine>TokenStart, originalLineNumber, lexeme))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>AddEscapedStringLiteralToken</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Attempts to add an escaped string literal token.</CodeDescription>
  <PartID>259317759</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub AddEscapedStringLiteralToken()</SourceLine>
   <SourceLine>/// Attempts to add an escaped string literal token.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Escaped string literals begin and end with a single quote (`'`). </SourceLine>
   <SourceLine>/// They may contain &gt;= 0 _escape sequences_ which begin with a</SourceLine>
   <SourceLine>/// backslash (`\`).</SourceLine>
   <SourceLine>/// This method assumes that the current character being evaluated is </SourceLine>
   <SourceLine>/// immediately after the opening single quote:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// 'Hello'</SourceLine>
   <SourceLine>///  ^</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// Permitted escape sequences:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// \n  Newline</SourceLine>
   <SourceLine>/// \t  Horizontal tab</SourceLine>
   <SourceLine>/// \'  Single quote</SourceLine>
   <SourceLine>/// \\  Backslash</SourceLine>
   <SourceLine>/// \u  Unicode codepoint</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// The Unicode codepoint escape sequence is `\u` followed </SourceLine>
   <SourceLine>/// by 1-8 hex digits.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Cache the original line number.</SourceLine>
   <SourceLine>Var originalLineNumber As Integer = LineNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Keep consuming characters until we hit an unescaped `'`.</SourceLine>
   <SourceLine>Var lexeme As String</SourceLine>
   <SourceLine>Var c As String</SourceLine>
   <SourceLine>Var terminated As Boolean = False</SourceLine>
   <SourceLine>While Not AtEnd</SourceLine>
   <SourceLine>c = Advance</SourceLine>
   <SourceLine>If c = "'" Then</SourceLine>
   <SourceLine>// End of the string.</SourceLine>
   <SourceLine>terminated = True</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>ElseIf c = EndOfLine.UNIX Then // A multiline string literal.</SourceLine>
   <SourceLine>LineNumber = LineNumber + 1</SourceLine>
   <SourceLine>ElseIf c = "\" Then</SourceLine>
   <SourceLine>// Start of an escape sequence.</SourceLine>
   <SourceLine>If Match("n") Then</SourceLine>
   <SourceLine>// Newline (`\n`).</SourceLine>
   <SourceLine>lexeme = lexeme + EndOfLine.UNIX</SourceLine>
   <SourceLine>ElseIf Match("t") Then</SourceLine>
   <SourceLine>// Horizontal tab (`\t`).</SourceLine>
   <SourceLine>lexeme = lexeme + &amp;u0009</SourceLine>
   <SourceLine>ElseIf Match("\") Then</SourceLine>
   <SourceLine>// Escaped backslash (`\\`).</SourceLine>
   <SourceLine>lexeme = lexeme + "\"</SourceLine>
   <SourceLine>ElseIf Match("'") Then</SourceLine>
   <SourceLine>// Escaped single quote (`'`).</SourceLine>
   <SourceLine>lexeme = lexeme + "'"</SourceLine>
   <SourceLine>ElseIf Match("u") Then</SourceLine>
   <SourceLine>// Unicode codepoint (`\u`).</SourceLine>
   <SourceLine>// There must be 1-8 hex digits immediately following this.</SourceLine>
   <SourceLine>If Not IsHexDigit(Peek) Then</SourceLine>
   <SourceLine>Error("Expected a hex digit after the `\u` escape sequence.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the hex digits.</SourceLine>
   <SourceLine>Var hex As String</SourceLine>
   <SourceLine>For i As Integer = 1 To 8</SourceLine>
   <SourceLine>If Not IsHexDigit(Peek) Then</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>hex = hex + Advance</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The next character must be non-alphanumeric.</SourceLine>
   <SourceLine>If IsAlpha(Peek) Then</SourceLine>
   <SourceLine>Error("Expected a non-alphanumeric character after a " + _</SourceLine>
   <SourceLine>"Unicode codepoint escape sequence.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the codepoint.</SourceLine>
   <SourceLine>Var codepoint As Integer = Integer.FromHex(hex)</SourceLine>
   <SourceLine>Try</SourceLine>
   <SourceLine>lexeme = lexeme + Text.FromUnicodeCodepoint(codepoint)</SourceLine>
   <SourceLine>Catch e</SourceLine>
   <SourceLine>// Invalid codepoint.</SourceLine>
   <SourceLine>Error("Invalid Unicode codepoint `" + hex + "`.")</SourceLine>
   <SourceLine>End Try</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Error("Unrecognised escape sequence: `\" + Peek + "`.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>lexeme = lexeme + c</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Make sure the literal was terminated.</SourceLine>
   <SourceLine>If Not terminated Then</SourceLine>
   <SourceLine>Error("Unterminated string literal. Expected a closing single quote.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Create the token.</SourceLine>
   <SourceLine>Tokens.Add(New ObjoToken(Objo.TokenTypes.StringLiteral, TokenStart, _</SourceLine>
   <SourceLine>originalLineNumber, lexeme))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>IdentifierOrReservedWord</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Attempts to consume an identifier or reserved word and return it. May raise an [ObjoTokeniserException].</CodeDescription>
  <PartID>1689939967</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IdentifierOrReservedWord() As ObjoToken</SourceLine>
   <SourceLine>/// Attempts to consume an identifier or reserved word and return it. </SourceLine>
   <SourceLine>/// May raise an [ObjoTokeniserException].</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// This method is called from [NextToken] and it assumes we've</SourceLine>
   <SourceLine>/// already consumed the first character of a potential identifier or </SourceLine>
   <SourceLine>/// reserved word (i.e. a letter).</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// If age = 80</SourceLine>
   <SourceLine>///     ^</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// </SourceLine>
   <SourceLine>/// Valid Objo identifiers begin with a letter and may contain any number</SourceLine>
   <SourceLine>/// of alphanumeric characters.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Consume all alphanumeric characters and underscores.</SourceLine>
   <SourceLine>While StringKit.IsLetterDigitOrUnderscore(Peek)</SourceLine>
   <SourceLine>Call Advance</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the lexeme.</SourceLine>
   <SourceLine>Var lexeme As String = Source.Middle(TokenStart, Current - TokenStart)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Determine if this lexeme is a reserved word or an identifier.</SourceLine>
   <SourceLine>Var type As Objo.TokenTypes = _</SourceLine>
   <SourceLine>Objo.ReservedWords.Lookup(lexeme, Objo.TokenTypes.Identifier)</SourceLine>
   <SourceLine>If type = Objo.TokenTypes.Identifier Then</SourceLine>
   <SourceLine>Return New ObjoToken(type, TokenStart, LineNumber, lexeme)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>// Keywords and other reserved words (like "true") don't need</SourceLine>
   <SourceLine>// the lexeme to be stored.</SourceLine>
   <SourceLine>Return New ObjoToken(type, TokenStart, LineNumber)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>ObjoToken</ItemResult>
 </Method>
 <Property>
  <ItemName>Source</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The original source code (after line ending standardisation).</CodeDescription>
  <PartID>1203677183</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Source As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Source As String</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Chars()</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The characters of the standardised source code to be tokenised.</CodeDescription>
  <PartID>1802956799</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Chars() As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Chars() As String</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Lines()</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Individual source code lines.</CodeDescription>
  <PartID>2025295871</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Lines() As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Lines() As String</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Tokens()</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The token's generated so far.</CodeDescription>
  <PartID>863107071</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Tokens() As ObjoToken</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Tokens() As ObjoToken</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>TokenStart</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>0-based index in `Chars` that the current token starts at.</CodeDescription>
  <PartID>1814427647</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>TokenStart As Integer = 0</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>TokenStart As Integer = 0</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Current</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>0-based index in `Chars` where the tokeniser currently is.</CodeDescription>
  <PartID>745367551</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Current As Integer = 0</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Current As Integer = 0</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>LineNumber</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The 1-based number of the line currently being processed.</CodeDescription>
  <PartID>1423382527</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>LineNumber As Integer = 1</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>LineNumber As Integer = 1</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <ViewBehavior>
  <ViewProperty>
   <ObjName>Name</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Index</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <PropertyValue>-2147483648</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Super</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Left</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Top</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
 </ViewBehavior>
 <Constant>
  <ItemName>QUOTE</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The double quote character.</CodeDescription>
  <PartID>419168255</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>"</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
</block>
</RBProject>
